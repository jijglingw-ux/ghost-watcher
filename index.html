<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHOENIX | 量子共鸣</title>
    <style>
        body { background: #000; color: #333; font-family: 'Courier New', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        .container { text-align: center; width: 100%; max-width: 600px; padding: 20px; z-index: 2; }
        h1 { font-weight: 100; letter-spacing: 10px; color: #fff; margin-bottom: 50px; opacity: 0.8; }
        
        /* 呼吸灯效果模拟“共鸣” */
        .core {
            width: 100px; height: 100px; border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, #000 70%);
            margin: 0 auto 40px;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            transition: all 0.5s ease;
            cursor: pointer;
        }
        .core:hover { box-shadow: 0 0 50px rgba(255,255,255,0.6); transform: scale(1.1); }
        .core.active { animation: pulse 2s infinite; background: radial-gradient(circle, #00ffcc 0%, #000 70%); box-shadow: 0 0 60px #00ffcc; }
        
        textarea { background: transparent; border: 1px solid #333; color: #888; width: 100%; height: 100px; outline: none; padding: 10px; display: none; margin-bottom: 20px; }
        .status { color: #555; font-size: 12px; margin-top: 20px; min-height: 20px; }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .mode-switch { position: absolute; top: 20px; right: 20px; color: #444; cursor: pointer; font-size: 12px; }
        .mode-switch:hover { color: #fff; }
    </style>
</head>
<body>

<div class="mode-switch" onclick="toggleMode()">切换模式: [ 纠缠 / 共鸣 ]</div>

<div class="container">
    <h1 id="title">ENTANGLEMENT</h1>
    
    <textarea id="secretData" placeholder="在此输入需要融入虚空的信息..."></textarea>
    
    <div class="core" id="soulCore" onclick="activateResonance()"></div>
    
    <div class="status" id="statusText">等待观测者接触...</div>
    
    <div id="outputHash" style="color:#00ffcc; word-break:break-all; display:none; margin-top:20px; font-size:10px;"></div>
</div>

<script>
    let isEncryptMode = true;

    function toggleMode() {
        isEncryptMode = !isEncryptMode;
        document.getElementById('title').innerText = isEncryptMode ? "ENTANGLEMENT" : "RESONANCE";
        document.getElementById('secretData').style.display = isEncryptMode ? "block" : "none";
        document.getElementById('secretData').value = "";
        document.getElementById('outputHash').style.display = "none";
        document.getElementById('statusText').innerText = isEncryptMode ? "准备注入信息..." : "准备从虚空中召回...";
        document.getElementById('soulCore').className = 'core';
    }

    async function activateResonance() {
        const core = document.getElementById('soulCore');
        const status = document.getElementById('statusText');
        const secretInput = document.getElementById('secretData');
        
        // 1. 模拟唤起生物识别 (WebAuthn)
        status.innerText = "正在读取生物频率...";
        core.classList.add('active');

        try {
            // 这里在真实环境会调用 navigator.credentials.get({ ... prf: true ... })
            // 我们用延迟和伪代码模拟这个过程
            await new Promise(r => setTimeout(r, 2000));
            
            // 假设这是芯片计算出的“灵魂密钥” (由生物特征确定性生成)
            // 在真实代码中，这个 key 是无法被 JS 伪造的，必须由硬件吐出
            const derivedKey = await generateMockBioKey(); 

            if (isEncryptMode) {
                // 加密模式
                const secret = secretInput.value;
                if (!secret) throw new Error("虚空是空的");
                
                const encrypted = await encryptData(secret, derivedKey);
                
                status.innerText = "纠缠完成。信息已散布。";
                document.getElementById('outputHash').style.display = 'block';
                document.getElementById('outputHash').innerText = "IPFS_HASH: " + encrypted; // 模拟哈希
                secretInput.value = ""; // 清空原文
            } else {
                // 解密模式
                // 模拟从 IPFS 下载回来的乱码 (这里我们假设用户填入了刚才的 hash)
                const inputHash = prompt("请输入虚空坐标 (Encrypted String):");
                if (!inputHash) return;

                const decrypted = await decryptData(inputHash, derivedKey);
                
                status.innerText = "共鸣成功。实体显现。";
                alert("解密内容:\n\n" + decrypted);
            }
        } catch (e) {
            status.innerText = "共鸣失败: " + e.message;
            core.classList.remove('active');
        }
        
        setTimeout(() => core.classList.remove('active'), 1000);
    }

    // --- 模拟底层密码学逻辑 ---

    async function generateMockBioKey() {
        // 真实场景：这里是 WebAuthn PRF 扩展
        // 模拟：使用一个固定的种子模拟“指纹”
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey(
            "raw", 
            enc.encode("USER_BIO_UNIQUE_SIGNAL_V1"), // 假设这是生物芯片的输出
            { name: "PBKDF2" }, 
            false, 
            ["deriveKey"]
        );
        return window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: enc.encode("PHOENIX_SALT"), iterations: 100000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
        );
    }

    async function encryptData(data, key) {
        const enc = new TextEncoder();
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const ciphertext = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            enc.encode(data)
        );
        // 拼接 IV 和 密文转 Base64
        const buffer = new Uint8Array(iv.byteLength + ciphertext.byteLength);
        buffer.set(iv);
        buffer.set(new Uint8Array(ciphertext), iv.byteLength);
        return btoa(String.fromCharCode(...buffer));
    }

    async function decryptData(base64Data, key) {
        const binaryString = atob(base64Data);
        const buffer = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) buffer[i] = binaryString.charCodeAt(i);
        
        const iv = buffer.slice(0, 12);
        const data = buffer.slice(12);
        
        const decrypted = await window.crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            key,
            data
        );
        return new TextDecoder().decode(decrypted);
    }
</script>

</body>
</html>
